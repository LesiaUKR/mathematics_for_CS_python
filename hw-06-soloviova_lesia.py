# -*- coding: utf-8 -*-
"""goit-numericalpy-hw-06-soloviova_lesia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OferovA3IGmqzPdfU5U4LWafwg8y40-L
"""

import os
import librosa
import librosa.display
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import SpectralClustering
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.preprocessing import LabelEncoder
import zipfile
import requests

print("1. Завантаження та розпакування даних")

# URL для завантаження даних
url = "https://github.com/karoldvl/ESC-50/archive/master.zip"
zip_file_path = "ESC-50-master.zip"
download_path = "./"

# Завантаження архіву
if not os.path.exists(zip_file_path):
    print("Завантаження даних...")
    response = requests.get(url)
    with open(zip_file_path, "wb") as file:
        file.write(response.content)
    print("Завантаження завершено.")

# Розпакування архіву
if not os.path.exists(download_path):
    print("Розпакування даних...")
    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
        zip_ref.extractall("./")
    print("Розпакування завершено.")
else:
    print("Дані вже завантажені та розпаковані.")

# Перевірка структури після розпакування
print("Структура папки після розпакування:")
!ls -R {download_path}

# Завантаження мета-інформації
metadata_path = os.path.join(download_path, "ESC-50-master", "meta", "esc50.csv")
df = pd.read_csv(metadata_path)

# Виведення перших рядків метаданих
print("\nМета-інформація:")
print(df.head())

# Виведення унікальних категорій
unique_categories = df['category'].unique()
print("Доступні категорії звуків:")
for category in unique_categories:
    print(category)

# Вибірка звуків з мітками
selected_labels = ['dog','chirping_birds', 'sea_waves']
filtered_df = df[df['category'].isin(selected_labels)].reset_index(drop=True)

# Перевірка кількості файлів для кожної категорії
print("Кількість файлів для кожної категорії:")
print(filtered_df['category'].value_counts())

# Виведення інформації про вибірку
print(f"Знайдено {len(filtered_df)} файлів для категорій: {selected_labels}")

print("3: Завантаження аудіофайлів та генерація спектрограм")
# Функція для генерації спектрограм
def generate_spectrogram(file_path, n_fft=2048, hop_length=512):
    y, sr = librosa.load(file_path, sr=None)
    spectrogram = np.abs(librosa.stft(y, n_fft=n_fft, hop_length=hop_length))
    return spectrogram, sr

# Обробка всіх звуків
spectrograms = []
labels = []
for _, row in filtered_df.iterrows():
    file_path = os.path.join(download_path, "ESC-50-master", "audio", row['filename'])
    spectrogram, sr = generate_spectrogram(file_path)
    spectrograms.append(spectrogram)
    labels.append(row['category'])

print(f"\nЗгенеровано {len(spectrograms)} спектрограм.")

print("4: Узагальнення спектрограм за допомогою пулінгу")
# Функція для пулінгу
def pooling(spectrogram, pool_size=(2, 2)):
    pooled = spectrogram[:len(spectrogram) // pool_size[0] * pool_size[0], :len(spectrogram[0]) // pool_size[1] * pool_size[1]]
    return pooled.reshape(pooled.shape[0] // pool_size[0], pool_size[0], -1, pool_size[1]).mean(axis=(1, 3))

# Застосовуємо пулінг до всіх спектрограм
pooled_spectrograms = [pooling(spectrogram) for spectrogram in spectrograms]

print(f"Узагальнено {len(pooled_spectrograms)} спектрограм.")

print("5: Перетворення спектрограм у вектори")
# Перетворення спектрограм у вектори
flattened_spectrograms = [spectrogram.flatten() for spectrogram in pooled_spectrograms]

print(f"Перетворено {len(flattened_spectrograms)} спектрограм у вектори.")

print("6: Масштабування ознак")
# Масштабування ознак
scaler = StandardScaler()
scaled_data = scaler.fit_transform(flattened_spectrograms)

print("Ознаки масштабовано.")

print("7: Кластеризація за допомогою SpectralClustering")
# Кодування міток у числові значення
label_encoder = LabelEncoder()
numeric_labels = label_encoder.fit_transform(labels)

# Кластеризація за допомогою SpectralClustering
n_clusters = len(selected_labels)
clustering = SpectralClustering(n_clusters=n_clusters, affinity='nearest_neighbors', random_state=42)
cluster_labels = clustering.fit_predict(scaled_data)

print("Кластеризація завершена.")

print("8: Оцінка результатів кластеризації")
# Оцінка кластеризації
print("Класифікація:")
print(classification_report(numeric_labels, cluster_labels, zero_division=0))
print("Матриця плутанини:")
conf_matrix = confusion_matrix(numeric_labels, cluster_labels)
print(conf_matrix)

# Висновок
if conf_matrix[0, 0] + conf_matrix[1, 1] > conf_matrix[0, 1] + conf_matrix[1, 0]:
    print("Кластеризація пройшла успішно: звуки різного походження розділені.")
else:
    print("Кластеризація не впоралася: звуки різного походження переплутані.")

# Додавання результатів кластеризації до DataFrame
filtered_df['cluster'] = cluster_labels

# Візуалізація спектрограм для кількох записів з кожного кластеру
for cluster_id in range(n_clusters):
    cluster_subset = filtered_df[filtered_df['cluster'] == cluster_id]
    print(f"Кластер {cluster_id}: {cluster_subset['category'].unique()}")
    for _, row in cluster_subset.head(2).iterrows():
        file_path = os.path.join(download_path, "ESC-50-master", "audio", row['filename'])
        y, sr = librosa.load(file_path, sr=None)
        plt.figure(figsize=(10, 4))
        librosa.display.specshow(librosa.amplitude_to_db(np.abs(librosa.stft(y)), ref=np.max), sr=sr, x_axis='time', y_axis='log')
        plt.colorbar(format='%+2.0f dB')
        plt.title(f"{row['category']} - Кластер {cluster_id}")
        plt.show()

print("""
1. Перетворення Фур'є дозволяє перейти від часової області до частотної, що дає змогу виявити ключові спектральні характеристики звукових сигналів.
2. Спектрограми, отримані за допомогою перетворення Фур'є, є ефективними для аналізу звуків, таких як 'dog', 'chirping_birds' та 'sea_waves', оскільки вони дозволяють виділити унікальні частотні компоненти для кожного типу звуку.
3. Однак перетворення Фур'є має обмеження: воно не враховує часову зміну частот, що може бути важливим для звуків із складними часово-частотними характеристиками.
4. Для покращення результатів кластеризації рекомендується використовувати більш спеціалізовані методи, такі як MFCC (Mel-Frequency Cepstral Coefficients), які враховують особливості людського слуху.
5. Перетворення Фур'є є важливим інструментом для вилучення ознак, але для складних задач кластеризації його слід комбінувати з іншими методами обробки звуку.
""")